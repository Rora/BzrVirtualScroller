@using Microsoft.Extensions.Logging
@implements IDisposable
@inject ILogger<VirtualScroller> Logger
@inject IJSRuntime JSRuntime

<div>Current item @_currentItem?.Value</div>
<div @ref="_containerElement">

    @for (var i = 0; i < _items.Count; i++)
    {
        var index = i; /* we do this since i will change in the next iteration so it can't be used in lambda's */
        var item = _items[i];
        <div @key="item.Id" data-bzr-virtual-scroller-item-id="@item.Id" style="border: 1px solid black; height: 200px; padding: 10px; margin-bottom: 10px;">
            @item.Value <button @onclick="(async () => await SetCurrentItemAsync(index))">Set as current item</button>
        </div>
    }
</div>

@code {
    private DotNetObjectReference<VirtualScroller> _virtualScrollerObjRef;
    private ElementReference _containerElement;
    private List<Func<ValueTask>> _actionsAfterNextRender = new List<Func<ValueTask>>(); //This allows us to call JS after blazor rendered
    private bool _pauseRendering = false; //setting this prevent useless renders on await in the middle of a function
    private bool _enableViewPortObserving = false; //viewport observing before init is dodgy

    private int _nrOfItemsAboveViewPort = 20;
    private int _nrOfItemsInViewPort = 5;
    private int _nrOfItemsBelowViewPort = 20;
    private int _refreshItemsListThreshold = 10; //The nr of items remaining before loading new entries
    private VirtualScrollerEntry _currentItem;
    private List<VirtualScrollerEntry> _items = new List<VirtualScrollerEntry>();
    private Func<ItemProducerArgs, ValueTask<IEnumerable<VirtualScrollerEntry>>> _itemProducer;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        SetDummyData();

        _virtualScrollerObjRef = DotNetObjectReference.Create(this);
        var itemsInViewPort = await _itemProducer(new ItemProducerArgs { NrOfItemsToLoad = _nrOfItemsBelowViewPort, ScrollDirection = ScrollDirection.Down });
        _items = itemsInViewPort
            .Concat(await GetItemsAfterIdAsync(itemsInViewPort.Last().Id, _nrOfItemsBelowViewPort))
            .ToList();

        ScheduleAsyncActionAfterRender(() => JSRuntime.InvokeVoidAsync("bzrVirtualScroller.init", _containerElement, _virtualScrollerObjRef));
        ScheduleAsyncActionAfterRender(() => JSRuntime.InvokeVoidAsync("bzrVirtualScroller.ensureAllItemIntersectionsAreObserved"));
    }

    private async Task<IEnumerable<VirtualScrollerEntry>> GetItemsAfterIdAsync(string afterItemId, int nrOfItems)
    {
        return await _itemProducer(new ItemProducerArgs { ItemId = afterItemId, NrOfItemsToLoad = nrOfItems, ScrollDirection = ScrollDirection.Down });
    }

    private async Task<IEnumerable<VirtualScrollerEntry>> GetItemsBeforeIdAsync(string beforeItemId, int nrOfItems)
    {
        return await _itemProducer(new ItemProducerArgs { ItemId = beforeItemId, NrOfItemsToLoad = nrOfItems, ScrollDirection = ScrollDirection.Up });
    }

    private async Task SetCurrentItemAsync(int index)
    {
        Logger.LogDebug("Setting current item index {0}", index);
        _currentItem = _items[index];
        await UpdateItemsListAsync();
    }

    //This lock prevents multiple UpdateViewportAsync calls running concurrently (this method isn't thread safe)
    System.Threading.SemaphoreSlim _updateViewportLock = new System.Threading.SemaphoreSlim(1);

    [JSInvokable]
    public async Task UpdateViewportAsync(IEnumerable<string> visibleItemIds)
    {
        await _updateViewportLock.WaitAsync();
        _pauseRendering = true;

        Logger.LogDebug("{0} invoked with ids {1}", nameof(UpdateViewportAsync), string.Join(", ", visibleItemIds));

        //Ignore the first update
        if (!_enableViewPortObserving)
        {
            _enableViewPortObserving = true;
            _updateViewportLock.Release();
            return;
        }

        //Nothing visible keep things as they were
        if (!visibleItemIds.Any())
        {
            _updateViewportLock.Release();
            return;
        }

        Logger.LogDebug("'{0}'", visibleItemIds.First());
        Logger.LogDebug("AllItems {0}", string.Join(", ", _items.Select(e => e.Id)));

        var itemIndexes = visibleItemIds
            .Select(id => _items.FindIndex(entry => entry.Id == id))
            .OrderBy(itemIndex => itemIndex)
            .ToArray();
        var topViewPortItemIndex = itemIndexes.First();
        var bottomViewPortItemIndex = itemIndexes.Last();

        Logger.LogDebug("Topviewport index is {0}", topViewPortItemIndex);

        _currentItem = _items[topViewPortItemIndex]; //todo
        var anyChange = await UpdateItemsListAsync();

        if (anyChange)
        {
            this.ScheduleActionAfterRender(() => _updateViewportLock.Release());
            _pauseRendering = false;
            this.StateHasChanged();
        }
        else
        {
            _pauseRendering = false;
            _updateViewportLock.Release();
        }
    }

    #region UpdateItemsListAsync
    /// <summary>
    /// Updates the items list if the user has scrolled near the top or botttom
    /// This method tries to retain the same nr of elements for perf reasons.
    ///     The optimization has 1 exception:
    ///     When the user scrolls near the end (can be top or bottom) of the list the nr of elements will decrease
    /// </summary>
    /// <returns></returns>
    private async Task<bool> UpdateItemsListAsync()
    {
        Logger.LogDebug("Updating items list");
        var anyChange = false;

        if (await AddBottomItemsIfBottomIsInSightAsync())
        {
            RemoveTopItemsIfTopIsFarAway();
            anyChange = true;
        }

        if (await PrependTopItemsIfTopIsInSightAsync())
        {
            RemoveBottomItemsIfBottomIsFarAway();
            anyChange = true;
        }

        if (anyChange)
        {
            ScheduleAsyncActionAfterRender(() => JSRuntime.InvokeVoidAsync("bzrVirtualScroller.ensureAllItemIntersectionsAreObserved"));
        }

        return anyChange;
    }

    private async Task<bool> AddBottomItemsIfBottomIsInSightAsync()
    {
        var currentItemIndex = _items.IndexOf(_currentItem);

        //Check if threshold below current item reached
        var nrOfItemsBelowCurrentItem = _items.Count - currentItemIndex;
        if (nrOfItemsBelowCurrentItem < _refreshItemsListThreshold)
        {
            Logger.LogDebug("Loading items to add to the bottom of the list");
            //TODO see why only 19 are added and not 20
            var nrOfItemsToLoad = _nrOfItemsBelowViewPort - nrOfItemsBelowCurrentItem;
            var newItems = await GetItemsAfterIdAsync(_items.Last().Id, nrOfItemsToLoad);
            _items.AddRange(newItems.Take(nrOfItemsToLoad));
            return true;
        }

        return false;
    }

    private async Task<bool> PrependTopItemsIfTopIsInSightAsync()
    {
        //Check if threshold above current item reached
        var currentItemIndex = _items.IndexOf(_currentItem);
        var nrOfItemsAboveCurrentItem = currentItemIndex;
        if (nrOfItemsAboveCurrentItem < _refreshItemsListThreshold)
        {
            Logger.LogDebug("Loading items to add to the top of the list");
            var nrOfItemsToLoad = _nrOfItemsAboveViewPort - nrOfItemsAboveCurrentItem;
            var newItems = await GetItemsBeforeIdAsync(_items[0].Id, nrOfItemsToLoad);
            _items.InsertRange(0, newItems.Take(nrOfItemsToLoad).Reverse());
            ScheduleAsyncActionAfterRender(async () => await JSRuntime.InvokeAsync<bool>("bzrVirtualScroller.scrollPastTopItems", nrOfItemsToLoad));
            return true;
        }

        return false;
    }

    private void RemoveBottomItemsIfBottomIsFarAway()
    {
        //Check if there are to many items below the current item
        var currentItemIndex = _items.IndexOf(_currentItem);
        var nrOfItemsBelowCurrentItem = _items.Count - currentItemIndex;
        if (nrOfItemsBelowCurrentItem > _nrOfItemsBelowViewPort)
        {
            Logger.LogDebug("Removing items from the bottom of the list");
            var nrOfItemsToRemove = nrOfItemsBelowCurrentItem - _nrOfItemsBelowViewPort;
            _items = _items.Take(_items.Count - nrOfItemsToRemove).ToList();
        }
    }

    private void RemoveTopItemsIfTopIsFarAway()
    {
        //Check if there are to many items above the current item
        var currentItemIndex = _items.IndexOf(_currentItem);
        var nrOfItemsAboveCurrentItem = currentItemIndex;
        if (nrOfItemsAboveCurrentItem > _nrOfItemsAboveViewPort)
        {
            Logger.LogDebug("Removing items from the top of the list");
            var nrOfItemsToRemove = nrOfItemsAboveCurrentItem - _nrOfItemsAboveViewPort;
            _items = _items.Skip(nrOfItemsToRemove).ToList();
        }
    }
    #endregion

    private void ScheduleActionAfterRender(Action action)
    {
        ScheduleAsyncActionAfterRender(() =>
        {
            action();
            return new ValueTask();
        });
    }

    private void ScheduleAsyncActionAfterRender(Func<ValueTask> asyncAction)
    {
        _actionsAfterNextRender.Add(asyncAction);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (_actionsAfterNextRender.Any())
        {
            //Pause rendering to prevent the await to trigger a new render
            this._pauseRendering = true;

            //Run JS after render
            foreach (var actionAfterRenderAsync in _actionsAfterNextRender)
            {
                await actionAfterRenderAsync();
            }
            _actionsAfterNextRender.Clear();

            this._pauseRendering = false;
        }
    }

    protected override bool ShouldRender()
    {
        return _pauseRendering ? false : base.ShouldRender();
    }

    private void SetDummyData()
    {
        _itemProducer = async (ItemProducerArgs args) =>
        {
            await Task.Delay(100); //Simulate a delay to see more realistic perf

            if (args.ItemId == null)
            {
                return (IEnumerable<VirtualScrollerEntry>)Enumerable.Range(1, args.NrOfItemsToLoad)
                    .Select(i => new VirtualScrollerEntry { Id = i.ToString(), Value = i.ToString() })
                    .ToArray();
            }

            var itemId = Int32.Parse(args.ItemId);
            var items = args.ScrollDirection == ScrollDirection.Down
                ? Enumerable.Range(itemId + 1, args.NrOfItemsToLoad)
                : Enumerable.Range(itemId - args.NrOfItemsToLoad, args.NrOfItemsToLoad).Reverse();

            return (IEnumerable<VirtualScrollerEntry>)items
                .Select(i => new VirtualScrollerEntry { Id = i.ToString(), Value = i.ToString() })
                .ToArray();
        };

        _currentItem = null;
    }

    public void Dispose()
    {
        this._virtualScrollerObjRef?.Dispose();
    }

}
